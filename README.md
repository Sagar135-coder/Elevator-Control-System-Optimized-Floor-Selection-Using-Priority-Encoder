# Elevator Control System Optimized Floor Selection Using Priority Encoder
## ðŸ“– Introduction

Modern elevator control systems must efficiently manage multiple floor requests while
minimizing travel time and unnecessary stops. Traditional elevator systems often process
requests sequentially, which can lead to increased waiting time and inefficient movement,
especially during peak usage.

This project, Elevator Control System â€“ Optimized Floor Selection Using Priority Encoder,
addresses this challenge by implementing a priority-based floor selection mechanism
for an 8-floor building using SystemVerilog. The system employs an 8-to-3 priority
encoder that evaluates all active floor requests simultaneously and selects the
highest-priority (highest-numbered) floor for service.

The design is implemented using three different modeling approachesâ€”gate-level,
behavioral, and dataflowâ€”to demonstrate flexibility in digital design and to compare
implementation trade-offs. To ensure correctness and robustness, each design is verified
using a SystemVerilog object-oriented (OOP) testbench framework incorporating
packages, interfaces, inheritance, and virtual functions.

Through exhaustive simulation and waveform analysis using Vivado, the project validates
accurate priority encoding under all possible input conditions, highlighting the
effectiveness of priority encoders in optimizing elevator control systems.



## ***What is a priority encoder***
A priority encoder is a combinational digital circuit that converts multiple input
signals into a compact binary representation by assigning priority to each input and
encoding only the highest-priority active request. In the context of this project, an
8-to-3 priority encoder is used to process floor requests in an 8-floor elevator system.
When multiple floor buttons are pressed simultaneously, the encoder evaluates all inputs
at the same time and outputs a 3-bit binary code corresponding to the highest-numbered
(active) floor, ensuring efficient and deterministic floor selection. This approach
eliminates ambiguity present in conventional encoders and avoids sequential request
processing, thereby reducing unnecessary stops and improving elevator response time.
Priority encoders are widely used in real-world systems such as elevator controllers,
interrupt handling circuits, and arbitration logic, where multiple competing requests
must be resolved quickly and reliably.


## ***Design and Implementation***
### ***Gate level design diagram*** ###
![image](https://github.com/sagar-c-s/Elevator-Control-System-Optimized-Floor-Selection-Using-Priority-Encoder/blob/main/structural_nor.jpg?raw=true)

### ***Behavioral design diagram *** ###
![image](https://github.com/sagar-c-s/Elevator-Control-System-Optimized-Floor-Selection-Using-Priority-Encoder/blob/main/Behavioral.jpg?raw=true)

### ***Data flow design diagram *** ###
![image]()

## ***Tech Stack***
[Vivado ML Edition - 2023.1](https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools/2023-1.html) used to implement the code.

## ***Working***

The working of a Gray Code Counter involves generation of gray code
using D flip-flops. The step-by-step operation of the counter is given below:
1. Initialization:
â€¢ The 3-bit gray code counter begins with an initialization phase.
â€¢ When the synchronous reset signal is asserted (active-high), all three D flipflops in the counter are synchronously reset to their initial state, which is
typically all zeros (binary 000).
â€¢ This ensures a well-defined starting point for the counter's operation.
2. Clock Triggered Operation:
â€¢ After initialization, the 3-bit Gray code counter starts counting based on the
clock signal.
â€¢ At each rising edge of the clock signal, the binary value stored in the counter is
updated according to the Gray code sequence.
â€¢ The Gray code sequence is designed such that only one-bit changes at a time
between consecutive values, which reduces errors during transitions. At each
rising edge of the clock signal, the binary value stored in the counter shifts one
position to the left.
3. Gray Code Sequence Generation:
â€¢ The sequence generated by the 3-bit Gray code counter follows the Gray code
pattern, where only one bit changes between adjacent values.
â€¢ For a 3-bit Gray code counter, the sequence proceeds as: 000, 001, 011, 010,
110, 111, 101, 100.
â€¢ This sequence ensures that only one-bit changes at each step, minimizing
glitches and errors during transitions.
4. Updating the Counter:
â€¢ During each clock cycle, the counter's binary value is updated based on the
Gray code pattern.
â€¢ The flip-flops are connected in such a way that the least significant bit (LSB)
follows the clock signal directly, while the higher-order bits are influenced by
the previous flip-flops.
â€¢ This connection ensures that only one bit changes at a time, maintaining the
Gray code sequence.
5. Asynchronous Reset Handling:
â€¢ Similar to the Johnson counter, the synchronous reset feature is essential for
the Gray code counter as well.
â€¢ If the synchronous reset signal is asserted, all flip-flops in the 3-bit Gray code
counter are reset to their initial state (000).
â€¢ This ensures a reliable and consistent initialization, preventing any ambiguity
during startup.
â€¢ In summary, a 3-bit Gray code counter using D flip-flops generates a cyclic
sequence of values following the Gray code pattern. The counter's operation is
synchronized with a clock signal, and its behavior is designed to minimize errors
during transitions by changing only one bit at a time. Synchronous reset
guarantees a predictable starting state for the counter.
6.Testing and Verification using OOP Concept:
Using an OOP approach for testing involves structuring of code using classes
and objects. This methodology helps in creating organized, modular, and
reusable code
â€¢ It involves defining of gray code counter class, testbench class, running of
different test cases.
â€¢ The logic of the counter is then implemented in the code.
â€¢ For each test case, the test bench simulates specific conditions (like clock
toggling, resetting, etc.) and checks if the counter's output matches the
expected output.
In summary, the OOP approach helps organize the testing process into
separate classes, in order to focus on each component's behavior and
interaction. It promotes modularity, reusability, and easier maintenance of your
testing code

### ***Excitation Table*** ###

![image](https://github.com/tusharshenoy/3-BIT-Gray-Code-Counter/assets/107348474/8b71b0ad-354c-4139-afa5-d4aeae87c509)

<br>

##	***Working of Code*** ##

â€¢ D Flip Flop code:
This module represents D flip-flop module with synchronous reset capability. The
module has inputs for data (D), reset, and clock (clk), as well as outputs for the flipflop state (Q) and its complement (Qb). It has an always block triggered by either a
rising clock edge or a rising reset edge, the flip-flop behaves such that when the
reset signal is active, the outputs Q and Qb are set to 0 and 1 respectively. When
reset is inactive, the flip-flop captures the input data D on the rising clock edge,
simultaneously producing Q as D and Qb as the complement of D.

â€¢ Gray Code Counter Structural Code:
This Verilog code defines a 3-bit Gray code counter module with synchronous reset
functionality. It takes input signals for clock (clk) and reset (reset), and outputs a 3-bit
Gray applications.

â€¢ Gray Code Using OOP :
This System Verilog code defines a package named gray_pkg, wrapping a class
named GrayCounter to model a 3-bit Gray code counter. The class holds member
variables for the counter's state (q), clock input (clk), and reset input (reset). The
constructor initializes the class's members with provided inputs. The update function
implements the counter's logic by shifting the current state and XORing specific bits
to generate the Gray code sequence. The getOutput function returns the current
state when reset is not active, and 0 when reset is asserted. This wrapped class
provides an organized and reusable way to simulate and work with a 3-bit Gray code
counter in digital designs.

â€¢ Testbench to compare Outputs:
This System Verilog code defines a package named gray_pkg, encapsulating a
classnamed GrayCounter to model a 3-bit Gray code counter. The class holds
member variables for the counter's state (q), clock input (clk), and reset input (reset).
The constructor initializes the class's members with provided inputs. The update
function implements the counter's logic by shifting the current state and XORing
specific bits to generate the Gray code sequence. The getoutput function returns the
current state when reset is not active, and 0 when reset is asserted. This
encapsulated classprovides an organized and reusable way to simulate and work
with a 3-bit Gray codecounter in digital designs.

##	***Results and Discussion*** ##

In this project, a 3-bit Gray Code Counter D flip-flops is executed using Verilog
code. The counter possesses the ability to count gray code sequence in ascending
order, and it includesa synchronous reset feature. When the reset signal is activated,
the counter reliably initializes to the 3-bit zeroes (000).
The 3-bit gray code counter generates a sequence of: 000, 001, 011, 010, 110, 111,
101, 100. It updates its count in sync with the clock signal, making sure that everything
happens at the right time.
The following waveform can be observed after the execution of the code.

### ***Waveform*** ###
![image](https://github.com/tusharshenoy/3-BIT-Gray-Code-Counter/assets/107348474/12835970-754c-4663-adec-82cda67a865b)


##	***Conclusion*** ##

In conclusion, the project successfully designed a 3-bit gray code counter using
D flip-flops, featuring a synchronous reset. The detailed code implementation is
provided in this report, a comprehensive discussion about the counter's intended
behavior is also included. The designed Gray Code Counter efficiently generates the
cyclic sequence: 000, 001, 011, 010, 110, 111, 101, 100.
The 3-bit Gray Code Counter holds potential applications and they are widely
used in rotary encoders to precisely measure rotation, avoiding errors that could arise
from traditional binary counting methods.
In simple term a gray code counter is a special type of counter that counts in a
specific way, it goes up from 000 till 100. These key features collectively contribute to
the counter's effectiveness and versatility, making it a valuable component for various
applications that require sequential and cyclic behavior. A detailed code and
explanation of the same along with the output waveform is included in this report


##	***References*** ##

1. Javatpoint. Verilog Gray Counter. Retrieved from https:[//www.javatpoint.com/verilog-gray-counter](//www.javatpoint.com/verilog-gray-counter)

2. YouTube. 3-Bit gray code counters circuit diagram. Retrieved from https:[//www.youtube.com/watch?v=gRH_gSrSk8k](//www.youtube.com/watch?v=gRH_gSrSk8k)

3. BrainKart. Synchronous counter design. Retrieved from https:[//www.brainkart.com/article/Design-ofSynchronous-Counters_12975/](//www.brainkart.com/article/Design-ofSynchronous-Counters_12975/)
